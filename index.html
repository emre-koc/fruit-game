<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Fruit Match Memory</title>
  <style>
    :root{
      --bg:#0b1220; --text:#eaf2ff; --muted:rgba(234,242,255,.7);
      --accent:#7cdbff; --good:#6dffb3; --bad:#ff6d6d; --shadow:0 12px 35px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:radial-gradient(1000px 700px at 20% 10%, #15204a 0%, var(--bg) 55%, #070b15 100%);
      min-height:100vh;
      min-height:100dvh;
      display:flex;
      justify-content:center;
      overflow-x:hidden;
    }
    
    /* Default (portrait) layout */
    .wrap{ width:min(980px,96vw); padding:18px 10px 26px; display:grid; gap:14px; }
    header{ display:grid; gap:10px; justify-items:center; text-align:center; }
    h1{ font-size:clamp(20px,3.6vw,34px); margin:6px 0 0; }
    .sub{ color:var(--muted); font-size:clamp(13px,2.2vw,16px); margin-top:-2px; }

    .panel{
      display:grid; gap:10px;
      background:rgba(10,16,34,.55);
      border:1px solid rgba(124,219,255,.18);
      border-radius:18px;
      padding:14px;
      box-shadow:var(--shadow);
    }
    .stats{ display:grid; grid-template-columns:repeat(5,minmax(0,1fr)); gap:10px; }
    .pill{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:10px 12px;
      text-align:center;
      box-shadow:0 10px 28px rgba(0,0,0,.15);
    }
    .pill .label{ font-size:12px; letter-spacing:.6px; text-transform:uppercase; color:var(--muted); margin-bottom:2px; }
    .pill .value{ font-size:18px; font-weight:800; }
    .pill .value.smallValue{ font-size:16px; font-weight:800; }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; }
    button,.toggle{
      border:0; border-radius:14px; padding:10px 14px;
      font-weight:800; cursor:pointer; user-select:none;
      color:var(--text);
      box-shadow:0 12px 26px rgba(0,0,0,.22);
    }
    button{
      background:linear-gradient(180deg, rgba(124,219,255,.18), rgba(124,219,255,.08));
      border:1px solid rgba(124,219,255,.25);
    }
    button:hover{ filter:brightness(1.06); }
    button:active{ transform:translateY(1px); }
    .toggle{
      display:flex; align-items:center; gap:10px;
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      font-weight:800;
      padding:10px 14px;
    }
    .toggle input{ width:18px; height:18px; accent-color:#7cdbff; }
    .message{ text-align:center; font-size:clamp(14px,2.6vw,18px); color:var(--muted); min-height:26px; }
    .small{ font-size:12px; color:var(--muted); text-align:center; }

    .boardWrap{ display:grid; place-items:center; padding-top:6px; position:relative; }
    .board{
      width:min(940px,96vw);
      display:grid; gap:10px;
      padding:14px;
      border-radius:22px;
      background:rgba(8,12,26,.55);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:var(--shadow);
      touch-action:manipulation;
      position:relative;
      z-index:1;
    }

    /* Big card mode gives larger, easier-to-tap cards (by limiting board width a bit and increasing gap/padding) */
    .board.bigMode{
      width:min(760px, 96vw);
      padding:16px;
      gap:12px;
    }

    .card{
      position:relative;
      aspect-ratio:1/1;
      border-radius:16px;
      transform-style:preserve-3d;
      transition:transform 220ms ease, filter 200ms ease;
      cursor:pointer;
      user-select:none;
      background:transparent;
      border:none;
      padding:0;
      -webkit-tap-highlight-color: transparent;
    }
    .card:focus{ outline:3px solid rgba(124,219,255,.55); outline-offset:2px; }
    .card.locked{ cursor:default; }
    .cardInner{ position:absolute; inset:0; border-radius:16px; transform-style:preserve-3d; transition:transform 220ms ease; }
    .card.isFlipped .cardInner{ transform:rotateY(180deg); }
    .face{
      position:absolute; inset:0;
      display:grid; place-items:center;
      border-radius:16px;
      backface-visibility:hidden;
      box-shadow:0 12px 26px rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
    }
    .front{ background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); }
    .back{
      transform:rotateY(180deg);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
    }
    .pattern{
      width:70%; height:70%; border-radius:14px;
      background:
        radial-gradient(circle at 20% 30%, rgba(124,219,255,.25) 0 18%, transparent 19%),
        radial-gradient(circle at 70% 60%, rgba(109,255,179,.18) 0 20%, transparent 21%),
        radial-gradient(circle at 40% 80%, rgba(255,109,109,.16) 0 16%, transparent 17%),
        linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.12);
      box-shadow:inset 0 0 0 2px rgba(255,255,255,.05);
    }
    .emoji{
      font-size:clamp(26px,5vw,48px);
      line-height:1;
      filter:drop-shadow(0 8px 14px rgba(0,0,0,.25));
    }
    .matched .back{
      border-color:rgba(109,255,179,.45);
      box-shadow:0 0 0 2px rgba(109,255,179,.18), 0 12px 26px rgba(0,0,0,.25);
    }
    .wrongFlash{ animation:wrong 280ms ease; }
    @keyframes wrong{
      0%{ filter:drop-shadow(0 0 0 rgba(255,109,109,0)); }
      50%{ filter:drop-shadow(0 0 18px rgba(255,109,109,.75)); }
      100%{ filter:drop-shadow(0 0 0 rgba(255,109,109,0)); }
    }
    .winGlow{ animation:glow 700ms ease-in-out 2; }
    @keyframes glow{
      0%{ box-shadow:var(--shadow); }
      50%{ box-shadow:0 0 40px rgba(124,219,255,.25), 0 0 70px rgba(109,255,179,.12), var(--shadow); }
      100%{ box-shadow:var(--shadow); }
    }

    #confetti{
      position:absolute; inset:0; z-index:2; pointer-events:none;
    }

    /* ========== POPUP MENU SYSTEM ========== */
    .menuBtn{
      display:none;
      position:fixed;
      z-index:100;
      width:48px; height:48px;
      border-radius:50%;
      background:linear-gradient(180deg, rgba(124,219,255,.25), rgba(124,219,255,.12));
      border:1px solid rgba(124,219,255,.35);
      color:var(--text);
      font-size:22px;
      cursor:pointer;
      box-shadow:0 8px 24px rgba(0,0,0,.35);
      transition:transform 0.2s ease, background 0.2s ease;
    }
    .menuBtn:hover{ transform:scale(1.05); }
    .menuBtn:active{ transform:scale(0.95); }
    
    #settingsBtn{ top:12px; right:12px; }
    #statsBtn{ top:12px; left:12px; }
    
    .popup{
      display:none;
      position:fixed;
      z-index:200;
      background:rgba(10,16,34,.96);
      border:1px solid rgba(124,219,255,.25);
      border-radius:20px;
      padding:20px;
      box-shadow:0 20px 60px rgba(0,0,0,.5);
      max-width:90vw;
      max-height:80vh;
      overflow-y:auto;
      animation:popupIn 0.25s ease;
    }
    @keyframes popupIn{
      from{ opacity:0; transform:scale(0.9) translateY(-10px); }
      to{ opacity:1; transform:scale(1) translateY(0); }
    }
    .popup.active{ display:block; }
    
    .popupHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:16px;
      padding-bottom:12px;
      border-bottom:1px solid rgba(255,255,255,.1);
    }
    .popupTitle{ font-size:18px; font-weight:800; margin:0; }
    .closeBtn{
      width:36px; height:36px;
      border-radius:50%;
      background:rgba(255,255,255,.1);
      border:1px solid rgba(255,255,255,.15);
      color:var(--text);
      font-size:18px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .closeBtn:hover{ background:rgba(255,255,255,.15); }
    
    .popupContent{ display:grid; gap:12px; }
    .popupContent .toggle{ width:100%; justify-content:flex-start; }
    .popupContent button{ width:100%; }
    
    .popupOverlay{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.5);
      z-index:150;
    }
    .popupOverlay.active{ display:block; }
    
    /* Stats popup specific */
    #statsPopup .stats{
      grid-template-columns:repeat(2,1fr);
      gap:8px;
    }
    #statsPopup .pill{ padding:8px 10px; }
    
    /* Landscape header bar */
    .landscapeHeader{
      display:none;
      position:fixed;
      top:0; left:0; right:0;
      height:56px;
      background:rgba(10,16,34,.92);
      border-bottom:1px solid rgba(124,219,255,.18);
      z-index:90;
      padding:0 70px;
      align-items:center;
      justify-content:center;
      gap:16px;
    }
    .landscapeHeader h1{
      font-size:20px;
      margin:0;
      white-space:nowrap;
    }
    .landscapeHeader .message{
      font-size:14px;
      min-height:auto;
      flex:1;
      text-align:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    
    /* Compact inline stats for landscape header */
    .inlineStats{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .inlineStat{
      display:flex;
      align-items:center;
      gap:4px;
      font-size:13px;
      color:var(--muted);
    }
    .inlineStat .val{
      font-weight:800;
      color:var(--text);
    }

    @media (max-width: 520px){
      .stats{ grid-template-columns:repeat(2,minmax(0,1fr)); }
      .board{ gap:8px; padding:12px; }
      .board.bigMode{ gap:10px; padding:14px; }
    }
    
    /* ========== iPad Landscape Mode ========== */
    @media (min-width: 700px) and (max-height: 600px) and (orientation: landscape),
           (min-width: 900px) and (max-height: 800px) and (orientation: landscape) {
      body{
        align-items:flex-start;
      }
      
      .wrap{
        width:100%;
        max-width:100%;
        padding:66px 16px 16px;
        gap:10px;
        min-height:100vh;
        min-height:100dvh;
      }
      
      /* Hide default header & panel in landscape */
      header{ display:none; }
      .panel{ display:none; }
      
      /* Show landscape header & menu buttons */
      .landscapeHeader{ display:flex; }
      .menuBtn{ display:flex; align-items:center; justify-content:center; }
      
      /* Board takes full available space */
      .boardWrap{
        flex:1;
        display:flex;
        align-items:center;
        justify-content:center;
        padding:0;
        width:100%;
        height:calc(100dvh - 72px);
      }
      
      .board{
        width:auto;
        height:min(calc(100dvh - 90px), 90vw);
        aspect-ratio:1/1;
        max-width:calc(100dvh - 90px);
        padding:12px;
        gap:8px;
      }
      .board.bigMode{
        height:min(calc(100dvh - 90px), 85vw);
        max-width:calc(100dvh - 90px);
        padding:14px;
        gap:10px;
      }
      
      .emoji{ font-size:clamp(20px,4vh,42px); }
      
      /* Popup positioning for landscape */
      #settingsPopup{
        top:70px;
        right:12px;
        width:280px;
      }
      #statsPopup{
        top:70px;
        left:12px;
        width:260px;
      }
    }
    
    /* Extra wide landscape (iPad Pro, etc) */
    @media (min-width: 1000px) and (max-height: 850px) and (orientation: landscape) {
      .board{
        height:min(calc(100dvh - 80px), 70vw);
        max-width:min(calc(100dvh - 80px), 70vw);
        gap:10px;
        padding:14px;
      }
      .board.bigMode{
        height:min(calc(100dvh - 80px), 65vw);
        max-width:min(calc(100dvh - 80px), 65vw);
      }
      .emoji{ font-size:clamp(24px,5vh,48px); }
    }
  </style>
</head>
<body>
  <!-- Landscape Header Bar -->
  <div class="landscapeHeader">
    <h1>üçì Fruit Match</h1>
    <div class="inlineStats">
      <div class="inlineStat"><span class="val" id="gridValueL">4√ó4</span></div>
      <div class="inlineStat">‚è±<span class="val" id="timeValueL">0:00</span></div>
      <div class="inlineStat">üëÜ<span class="val" id="movesValueL">0</span></div>
      <div class="inlineStat">‚úì<span class="val" id="matchesValueL">0/0</span></div>
      <div class="inlineStat">üèÜ<span class="val" id="winsValueL">0</span></div>
    </div>
    <div class="message" id="messageL"></div>
  </div>
  
  <!-- Menu Buttons (visible in landscape) -->
  <button class="menuBtn" id="statsBtn" title="Stats">üìä</button>
  <button class="menuBtn" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
  
  <!-- Popup Overlay -->
  <div class="popupOverlay" id="popupOverlay"></div>
  
  <!-- Stats Popup -->
  <div class="popup" id="statsPopup">
    <div class="popupHeader">
      <h2 class="popupTitle">üìä Stats</h2>
      <button class="closeBtn" data-close="statsPopup">‚úï</button>
    </div>
    <div class="popupContent">
      <div class="stats">
        <div class="pill"><div class="label">Grid</div><div class="value" id="gridValueP">4√ó4</div></div>
        <div class="pill"><div class="label">Time</div><div class="value" id="timeValueP">0:00</div></div>
        <div class="pill"><div class="label">Moves</div><div class="value" id="movesValueP">0</div></div>
        <div class="pill"><div class="label">Matches</div><div class="value smallValue" id="matchesValueP">0/0</div></div>
        <div class="pill"><div class="label">Wins</div><div class="value" id="winsValueP">0</div></div>
      </div>
      <div class="small" style="margin-top:8px;">
        Level up every <b>3 wins</b>: 4√ó4 ‚Üí 6√ó6 ‚Üí 8√ó8 ‚Üí 10√ó10
      </div>
    </div>
  </div>
  
  <!-- Settings Popup -->
  <div class="popup" id="settingsPopup">
    <div class="popupHeader">
      <h2 class="popupTitle">‚öôÔ∏è Settings</h2>
      <button class="closeBtn" data-close="settingsPopup">‚úï</button>
    </div>
    <div class="popupContent">
      <button id="newGameBtnP">üéÆ New Game</button>
      <button id="peekBtnP" title="Peek at all cards">üëÄ Peek</button>
      <button id="resetBtnP">üîÑ Reset Progress</button>
      <label class="toggle"><input id="soundToggleP" type="checkbox" checked />üîä Sound</label>
      <label class="toggle"><input id="easyToggleP" type="checkbox" />üòä Easy mode</label>
      <label class="toggle"><input id="voiceToggleP" type="checkbox" />üó£Ô∏è Kid voice</label>
      <label class="toggle"><input id="bigToggleP" type="checkbox" />üëÜ Big card mode</label>
    </div>
  </div>

  <div class="wrap">
    <header>
      <h1>üçì Fruit Match Memory</h1>
      <div class="sub">Flip two cards. If they match, they stay open. Match all to win!</div>
    </header>

    <div class="panel">
      <div class="stats">
        <div class="pill"><div class="label">Grid</div><div class="value" id="gridValue">4√ó4</div></div>
        <div class="pill"><div class="label">Time</div><div class="value" id="timeValue">0:00</div></div>
        <div class="pill"><div class="label">Moves</div><div class="value" id="movesValue">0</div></div>
        <div class="pill"><div class="label">Matches</div><div class="value smallValue" id="matchesValue">0/0</div></div>
        <div class="pill"><div class="label">Wins</div><div class="value" id="winsValue">0</div></div>
      </div>

      <div class="controls">
        <button id="newGameBtn">New Game</button>
        <button id="peekBtn" title="Peek at all cards for a moment">Peek üëÄ</button>
        <button id="resetBtn">Reset Progress</button>

        <label class="toggle" title="Sound beeps on/off"><input id="soundToggle" type="checkbox" checked />Sound</label>
        <label class="toggle" title="Easy mode: longer peek + optional peek after mistakes"><input id="easyToggle" type="checkbox" />Easy mode</label>
        <label class="toggle" title="Kid voice: says short phrases"><input id="voiceToggle" type="checkbox" />Kid voice</label>
        <label class="toggle" title="Big cards: easier taps (limits grid on small screens)"><input id="bigToggle" type="checkbox" />Big card mode</label>
      </div>

      <div class="message" id="message"></div>
      <div class="small">
        Even grids only: <b>4√ó4 ‚Üí 6√ó6 ‚Üí 8√ó8 ‚Üí 10√ó10</b> (level up every <b>3 wins</b>). ‚≠ê rating + confetti on win!
      </div>
    </div>

    <div class="boardWrap" id="boardWrap">
      <canvas id="confetti"></canvas>
      <div class="board" id="board" aria-label="Memory board"></div>
    </div>
  </div>

<script>
(() => {
  // Fruit emoji icons
  const FRUITS = [
    "üçé","üçê","üçä","üçã","üçå","üçâ","üçá","üçì","ü´ê","üçí",
    "ü•ù","üçç","ü•≠","üçë","üçà","üçè","üçÖ","ü••","üçí","üçä",
    "üçì","üçá","üçâ","üçé","ü•ù","üçç","ü•≠","ü´ê","üçã","üçå",
    "üçë","üçà","üçê","üçè","ü••","üçÖ","üçí","üçä","üçá","üçì",
    "ü´ê","ü•ù","üçç","ü•≠","üçé","üçê","üçâ","üçå","üçã","üçä"
  ];

  // State
  let wins = 0;
  let gridSize = 4;
  let moves = 0;
  let matches = 0;
  let totalPairs = 0;

  let firstPick = null;
  let secondPick = null;
  let busy = false;
  let wonThisRound = false;

  // Timer
  let timerId = null;
  let startMs = 0;
  let elapsedMs = 0;
  let timerRunning = false;

  // DOM - Main panel
  const board = document.getElementById("board");
  const boardWrap = document.getElementById("boardWrap");

  const gridValue = document.getElementById("gridValue");
  const timeValue = document.getElementById("timeValue");
  const movesValue = document.getElementById("movesValue");
  const matchesValue = document.getElementById("matchesValue");
  const winsValue = document.getElementById("winsValue");
  const message = document.getElementById("message");

  const newGameBtn = document.getElementById("newGameBtn");
  const resetBtn = document.getElementById("resetBtn");
  const peekBtn = document.getElementById("peekBtn");

  const soundToggle = document.getElementById("soundToggle");
  const easyToggle  = document.getElementById("easyToggle");
  const voiceToggle = document.getElementById("voiceToggle");
  const bigToggle   = document.getElementById("bigToggle");
  
  // DOM - Landscape header
  const gridValueL = document.getElementById("gridValueL");
  const timeValueL = document.getElementById("timeValueL");
  const movesValueL = document.getElementById("movesValueL");
  const matchesValueL = document.getElementById("matchesValueL");
  const winsValueL = document.getElementById("winsValueL");
  const messageL = document.getElementById("messageL");
  
  // DOM - Popups
  const statsBtn = document.getElementById("statsBtn");
  const settingsBtn = document.getElementById("settingsBtn");
  const popupOverlay = document.getElementById("popupOverlay");
  const statsPopup = document.getElementById("statsPopup");
  const settingsPopup = document.getElementById("settingsPopup");
  
  // DOM - Popup stats
  const gridValueP = document.getElementById("gridValueP");
  const timeValueP = document.getElementById("timeValueP");
  const movesValueP = document.getElementById("movesValueP");
  const matchesValueP = document.getElementById("matchesValueP");
  const winsValueP = document.getElementById("winsValueP");
  
  // DOM - Popup controls
  const newGameBtnP = document.getElementById("newGameBtnP");
  const resetBtnP = document.getElementById("resetBtnP");
  const peekBtnP = document.getElementById("peekBtnP");
  const soundToggleP = document.getElementById("soundToggleP");
  const easyToggleP = document.getElementById("easyToggleP");
  const voiceToggleP = document.getElementById("voiceToggleP");
  const bigToggleP = document.getElementById("bigToggleP");

  // Confetti
  const confettiCanvas = document.getElementById("confetti");
  const ctx = confettiCanvas.getContext("2d");
  let confetti = [];
  let confettiRAF = null;

  // --- Sound beeps (WebAudio)
  let audioCtx = null;
  function beep(freq=440, dur=0.08, type="sine", gain=0.04) {
    if (!soundToggle.checked) return;
    try {
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch {}
  }
  const soundFlip  = () => beep(520, 0.05, "sine", 0.03);
  const soundMatch = () => { beep(740,0.07,"triangle",0.05); beep(980,0.08,"triangle",0.05); };
  const soundWrong = () => beep(200, 0.12, "sawtooth", 0.03);
  const soundWin   = () => { beep(660,0.09,"triangle",0.06); setTimeout(()=>beep(880,0.1,"triangle",0.06),90); setTimeout(()=>beep(1100,0.12,"triangle",0.06),180); };

  // --- Kid voice (speechSynthesis)
  function speak(text) {
    if (!voiceToggle.checked) return;
    if (!("speechSynthesis" in window)) return;
    try {
      // Stop overlapping chatter
      window.speechSynthesis.cancel();

      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0;   // kid-friendly pace
      u.pitch = 1.2;  // a bit brighter
      u.volume = 1.0;

      // Try to pick an English voice if available
      const voices = window.speechSynthesis.getVoices?.() || [];
      const en = voices.find(v => /en/i.test(v.lang)) || voices[0];
      if (en) u.voice = en;

      window.speechSynthesis.speak(u);
    } catch {}
  }

  // Some browsers load voices async
  if ("speechSynthesis" in window) {
    window.speechSynthesis.onvoiceschanged = () => {};
  }

  // Helpers
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  function chooseIcons(pairCount){
    const pool = FRUITS.slice();
    shuffle(pool);
    if(pairCount <= pool.length) return pool.slice(0, pairCount);
    const out=[];
    for(let i=0;i<pairCount;i++) out.push(pool[i % pool.length]);
    return out;
  }
  function formatTime(ms){
    const totalSec = Math.floor(ms/1000);
    const m = Math.floor(totalSec/60);
    const s = totalSec%60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }
  function setMessage(text, tone=""){
    const color =
      tone==="good" ? "rgba(109,255,179,.95)" :
      tone==="bad"  ? "rgba(255,109,109,.95)" :
                      "rgba(234,242,255,0.7)";
    message.textContent = text;
    message.style.color = color;
    // Also update landscape message
    if(messageL){
      messageL.textContent = text;
      messageL.style.color = color;
    }
  }
  function updateStats(){
    const gridText = `${gridSize}√ó${gridSize}`;
    const timeText = formatTime(elapsedMs);
    const matchText = `${matches}/${totalPairs}`;
    
    // Main panel
    gridValue.textContent = gridText;
    movesValue.textContent = moves;
    matchesValue.textContent = matchText;
    winsValue.textContent = wins;
    timeValue.textContent = timeText;
    
    // Landscape header
    if(gridValueL) gridValueL.textContent = gridText;
    if(timeValueL) timeValueL.textContent = timeText;
    if(movesValueL) movesValueL.textContent = moves;
    if(matchesValueL) matchesValueL.textContent = matchText;
    if(winsValueL) winsValueL.textContent = wins;
    
    // Popup stats
    if(gridValueP) gridValueP.textContent = gridText;
    if(timeValueP) timeValueP.textContent = timeText;
    if(movesValueP) movesValueP.textContent = moves;
    if(matchesValueP) matchesValueP.textContent = matchText;
    if(winsValueP) winsValueP.textContent = wins;
  }

  function gridFromWins(w){
    // Every 3 wins: 4 -> 6 -> 8 -> 10
    const steps = Math.floor(w / 3);
    return clamp(4 + steps * 2, 4, 10);
  }

  function effectiveMaxGrid(){
    // Big card mode keeps it playable on touch screens.
    // If screen is small, limit to 8x8; otherwise allow 10x10.
    if (!bigToggle.checked) return 10;
    const smallScreen = Math.min(window.innerWidth, window.innerHeight) < 700;
    return smallScreen ? 8 : 10;
  }

  function computeGridForThisRound(){
    const desired = gridFromWins(wins);
    return Math.min(desired, effectiveMaxGrid());
  }

  function setBoardDensity(n){
    // slightly larger gaps in big mode for tap comfort
    if (bigToggle.checked) {
      board.classList.add("bigMode");
    } else {
      board.classList.remove("bigMode");
    }

    const baseGap =
      bigToggle.checked ? (n>=10 ? 7 : n>=8 ? 10 : n>=6 ? 12 : 12)
                        : (n>=10 ? 5 : n>=8 ? 7 : n>=6 ? 9 : 10);
    board.style.gap = `${baseGap}px`;
  }

  // Timer controls
  function stopTimer(){
    timerRunning = false;
    if(timerId) clearInterval(timerId);
    timerId = null;
  }
  function startTimer(){
    if(timerRunning) return;
    timerRunning = true;
    startMs = performance.now() - elapsedMs;
    timerId = setInterval(() => {
      elapsedMs = performance.now() - startMs;
      const timeText = formatTime(elapsedMs);
      timeValue.textContent = timeText;
      if(timeValueL) timeValueL.textContent = timeText;
      if(timeValueP) timeValueP.textContent = timeText;
    }, 200);
  }
  function resetTimer(){
    stopTimer();
    elapsedMs = 0;
    timeValue.textContent = "0:00";
  }

  // Cards
  function createCard(icon){
    const card = document.createElement("button");
    card.type = "button";
    card.className = "card";
    card.setAttribute("aria-label", "Memory card");
    card.dataset.icon = icon;
    card.dataset.matched = "false";
    card.dataset.locked = "false";

    card.innerHTML = `
      <div class="cardInner">
        <div class="face front"><div class="pattern"></div></div>
        <div class="face back"><div class="emoji">${icon}</div></div>
      </div>
    `;
    // Click is enough for touch too; we also stop double-tap zoom issues via viewport/meta + tap highlight.
    card.addEventListener("click", () => onCardClick(card));
    card.addEventListener("keydown", (e)=>{
      if(e.key==="Enter" || e.key===" "){ e.preventDefault(); onCardClick(card); }
    });
    return card;
  }

  function flip(card, on){
    if(on) card.classList.add("isFlipped");
    else card.classList.remove("isFlipped");
  }

  // Easy mode behavior
  function easyStartPeekMs(){
    return easyToggle.checked ? 1400 : 650;
  }
  function easyAfterWrongPeekMs(){
    // When easy mode is on, after a wrong match, briefly reveal all cards again.
    return easyToggle.checked ? 650 : 0;
  }

  // Game build
  function newGame(){
    wonThisRound = false;
    gridSize = computeGridForThisRound();

    const totalCards = gridSize * gridSize;
    totalPairs = totalCards / 2;

    moves = 0;
    matches = 0;
    firstPick = null;
    secondPick = null;
    busy = false;

    resetTimer();

    board.innerHTML = "";
    board.classList.remove("winGlow");

    board.style.gridTemplateColumns = `repeat(${gridSize}, minmax(0, 1fr))`;
    setBoardDensity(gridSize);

    const icons = chooseIcons(totalPairs);
    const deck = [];
    icons.forEach(icon => deck.push(icon, icon));
    shuffle(deck);

    for(const icon of deck){
      board.appendChild(createCard(icon));
    }

    setMessage(`New game! Match all the fruits!`);
    speak("New game! Let's match the fruits!");
    updateStats();

    peek(easyStartPeekMs());
  }

  function onCardClick(card){
    if (busy || wonThisRound) return;
    if (card.dataset.locked === "true") return;
    if (card.dataset.matched === "true") return;
    if (card === firstPick) return;

    startTimer();
    flip(card, true);
    soundFlip();

    if(!firstPick){
      firstPick = card;
      return;
    }

    secondPick = card;
    moves += 1;
    updateStats();

    const a = firstPick.dataset.icon;
    const b = secondPick.dataset.icon;

    if(a === b){
      firstPick.dataset.matched = "true";
      secondPick.dataset.matched = "true";
      firstPick.classList.add("matched","locked");
      secondPick.classList.add("matched","locked");

      matches += 1;
      updateStats();
      soundMatch();
      const msg = randomHappy();
      setMessage(msg, "good");
      speak("Yay! A match!");

      firstPick = null;
      secondPick = null;

      if(matches === totalPairs){
        handleWin();
      }
    } else {
      busy = true;
      soundWrong();
      firstPick.classList.add("wrongFlash");
      secondPick.classList.add("wrongFlash");
      const msg = randomTryAgain();
      setMessage(msg, "bad");
      speak("Oops! Try again!");

      setTimeout(()=>{
        flip(firstPick,false);
        flip(secondPick,false);
        firstPick.classList.remove("wrongFlash");
        secondPick.classList.remove("wrongFlash");
        firstPick=null; secondPick=null;

        // Easy mode: quick ‚Äúhelp peek‚Äù after mistakes
        const helpMs = easyAfterWrongPeekMs();
        if (helpMs > 0) {
          peek(helpMs);
        }
        busy=false;
      }, 650);
    }
  }

  // Stars
  function computeStars(grid, moves, elapsedMs){
    const pairs = (grid*grid)/2;
    const seconds = Math.max(1, Math.floor(elapsedMs/1000));

    // Easy mode makes rating a bit more forgiving (kids are learning)
    const easyBonus = easyToggle.checked ? 0.15 : 0;

    const movePerfect = pairs + Math.round(pairs*(0.25 + easyBonus));
    const moveOkay    = pairs + Math.round(pairs*(0.75 + easyBonus));

    const timePerfect = Math.round(pairs*(3 + easyBonus*3));
    const timeOkay    = Math.round(pairs*(6 + easyBonus*5));

    let stars = 1;
    const greatMoves = moves <= movePerfect;
    const goodMoves  = moves <= moveOkay;
    const greatTime  = seconds <= timePerfect;
    const goodTime   = seconds <= timeOkay;

    if (goodMoves && goodTime) stars = 2;
    if (greatMoves && greatTime) stars = 3;
    return stars;
  }
  const starsText = n => "‚≠ê".repeat(n) + "‚òÜ".repeat(3-n);

  function handleWin(){
    wonThisRound = true;
    stopTimer();
    soundWin();
    board.classList.add("winGlow");

    const stars = computeStars(gridSize, moves, elapsedMs);
    const starLine = `${starsText(stars)} (${formatTime(elapsedMs)}, ${moves} moves)`;

    wins += 1;
    updateStats();

    launchConfetti(1600);

    // Level info (even grids only)
    const desiredNext = gridFromWins(wins);
    const nextGrid = Math.min(desiredNext, effectiveMaxGrid());
    const leveledUp = nextGrid !== gridSize;

    if (leveledUp){
      setMessage(`üéâ You won! ${starLine}  Level up! Next: ${nextGrid}√ó${nextGrid}`, "good");
      speak("You won! Level up!");
    } else {
      const remaining = 3 - (wins % 3);
      setMessage(`üéâ You won! ${starLine}  ${remaining} more win${remaining===1?"":"s"} to level up!`, "good");
      speak("You won! Great job!");
    }

    // If big mode capped the grid, hint gently
    if (bigToggle.checked && desiredNext > nextGrid) {
      setTimeout(() => {
        setMessage(`üéà Big card mode is keeping the grid at ${nextGrid}√ó${nextGrid} for easier tapping.`, "");
      }, 1400);
    }
  }

  // Peek helper
  function peek(durationMs=900){
    if(busy) return;
    busy = true;
    const cards = [...board.querySelectorAll(".card")];
    cards.forEach(c => flip(c,true));
    setTimeout(()=>{
      cards.forEach(c => { if(c.dataset.matched !== "true") flip(c,false); });
      busy = false;
    }, durationMs);
  }

  function resetProgress(){
    wins = 0;
    setMessage("Progress reset. Back to 4√ó4!", "");
    speak("Reset! Back to the easy level.");
    newGame();
  }

  function randomHappy(){
    const msgs=["Nice match! üåü","Yay! You found a pair! üçì","Great job! üéà","Awesome! üöÄ","Perfect match! üéâ"];
    return msgs[Math.floor(Math.random()*msgs.length)];
  }
  function randomTryAgain(){
    const msgs=["Oops! Try again üôÇ","Not the same‚Ä¶ you can do it! üí™","Close! Flip two more! üß†","Keep trying! ‚≠ê","Almost! üåà"];
    return msgs[Math.floor(Math.random()*msgs.length)];
  }

  // Confetti
  function resizeConfettiCanvas(){
    const r = boardWrap.getBoundingClientRect();
    confettiCanvas.width = Math.floor(r.width * devicePixelRatio);
    confettiCanvas.height = Math.floor(r.height * devicePixelRatio);
    confettiCanvas.style.width = r.width + "px";
    confettiCanvas.style.height = r.height + "px";
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  function cancelConfetti(){
    if(confettiRAF) cancelAnimationFrame(confettiRAF);
    confettiRAF = null;
    confetti = [];
    ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
  }
  function launchConfetti(durationMs=1200){
    cancelConfetti();
    resizeConfettiCanvas();

    const r = boardWrap.getBoundingClientRect();
    const w = r.width, h = r.height;

    const count = Math.min(240, Math.max(90, gridSize * gridSize * 1.2));
    confetti = [];
    for(let i=0;i<count;i++){
      confetti.push({
        x: w * (0.2 + Math.random()*0.6),
        y: -10 - Math.random()*h*0.2,
        vx: (Math.random()*2 - 1) * (1.2 + Math.random()*1.5),
        vy: (2.2 + Math.random()*3.2),
        rot: Math.random()*Math.PI*2,
        vr: (Math.random()*0.2 - 0.1),
        size: 6 + Math.random()*8,
        life: 0,
        maxLife: 60 + Math.random()*55,
        hue: Math.floor(Math.random()*360),
        shape: Math.random() < 0.25 ? "circle" : "rect"
      });
    }

    const endAt = performance.now() + durationMs;
    function tick(){
      const now = performance.now();
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

      for(const p of confetti){
        p.life++;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.03;
        p.vx *= 0.995;
        p.rot += p.vr;

        const alpha = 1 - (p.life / p.maxLife);
        if(alpha <= 0) continue;

        ctx.save();
        ctx.globalAlpha = Math.max(0, alpha);
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = `hsl(${p.hue} 90% 60%)`;

        if(p.shape === "circle"){
          ctx.beginPath();
          ctx.arc(0,0,p.size*0.45,0,Math.PI*2);
          ctx.fill();
        } else {
          ctx.fillRect(-p.size/2, -p.size/3, p.size, p.size*0.66);
        }
        ctx.restore();
      }

      confetti = confetti.filter(p => p.life < p.maxLife && p.y < h + 80);

      if(now < endAt && confetti.length){
        confettiRAF = requestAnimationFrame(tick);
      } else {
        cancelConfetti();
      }
    }
    confettiRAF = requestAnimationFrame(tick);
  }

  // Buttons + toggles (main panel)
  newGameBtn.addEventListener("click", () => newGame());
  resetBtn.addEventListener("click", () => resetProgress());
  peekBtn.addEventListener("click", () => peek(easyToggle.checked ? 1400 : 900));

  // Sync function for toggles
  function syncToggle(main, popup, onChange){
    main.addEventListener("change", () => {
      popup.checked = main.checked;
      onChange(main.checked);
    });
    popup.addEventListener("change", () => {
      main.checked = popup.checked;
      onChange(popup.checked);
    });
  }
  
  // Sound toggle sync (no game restart needed)
  syncToggle(soundToggle, soundToggleP, () => {});
  
  // Easy toggle sync
  syncToggle(easyToggle, easyToggleP, (checked) => {
    setMessage(checked ? "Easy mode on! üëç" : "Easy mode off!", "");
    speak(checked ? "Easy mode on!" : "Easy mode off!");
    newGame();
  });
  
  // Big card toggle sync
  syncToggle(bigToggle, bigToggleP, (checked) => {
    setMessage(checked ? "Big card mode on! üëÜ" : "Big card mode off!", "");
    speak(checked ? "Big card mode on!" : "Big card mode off!");
    newGame();
  });
  
  // Voice toggle sync
  syncToggle(voiceToggle, voiceToggleP, (checked) => {
    setMessage(checked ? "Kid voice on! üó£Ô∏è" : "Kid voice off!", "");
    if(checked) speak("Hello! Let's play!");
    else if("speechSynthesis" in window) window.speechSynthesis.cancel();
  });
  
  // Popup buttons
  newGameBtnP.addEventListener("click", () => { closeAllPopups(); newGame(); });
  resetBtnP.addEventListener("click", () => { closeAllPopups(); resetProgress(); });
  peekBtnP.addEventListener("click", () => { closeAllPopups(); peek(easyToggle.checked ? 1400 : 900); });
  
  // Popup menu handling
  function openPopup(popup){
    closeAllPopups();
    popup.classList.add("active");
    popupOverlay.classList.add("active");
  }
  function closeAllPopups(){
    statsPopup.classList.remove("active");
    settingsPopup.classList.remove("active");
    popupOverlay.classList.remove("active");
  }
  
  statsBtn.addEventListener("click", () => openPopup(statsPopup));
  settingsBtn.addEventListener("click", () => openPopup(settingsPopup));
  popupOverlay.addEventListener("click", closeAllPopups);
  
  // Close buttons inside popups
  document.querySelectorAll(".closeBtn[data-close]").forEach(btn => {
    btn.addEventListener("click", () => {
      const popupId = btn.getAttribute("data-close");
      document.getElementById(popupId)?.classList.remove("active");
      popupOverlay.classList.remove("active");
    });
  });
  
  // Close popup on Escape key
  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape") closeAllPopups();
  });

  // Keep confetti correct on resize
  window.addEventListener("resize", () => { if(confettiRAF) resizeConfettiCanvas(); });

  // Start
  newGame();
})();
</script>
</body>
</html>