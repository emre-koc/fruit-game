<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Fruit Match Memory</title>
  <style>
    :root{
      --bg:#0b1220; --text:#eaf2ff; --muted:rgba(234,242,255,.7);
      --accent:#7cdbff; --good:#6dffb3; --bad:#ff6d6d; --shadow:0 12px 35px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:radial-gradient(1000px 700px at 20% 10%, #15204a 0%, var(--bg) 55%, #070b15 100%);
      min-height:100vh;
      display:-webkit-flex;
      display:flex;
      -webkit-justify-content:center;
      justify-content:center;
      overflow-x:hidden;
    }
    
    /* Default (portrait) layout */
    .wrap{ width:96vw; max-width:980px; padding:18px 10px 26px; display:grid; grid-gap:14px; }
    header{ display:grid; grid-gap:10px; justify-items:center; text-align:center; }
    h1{ font-size:24px; font-size:calc(20px + 1.4vw); margin:6px 0 0; }
    .sub{ color:var(--muted); font-size:14px; font-size:calc(13px + 0.3vw); margin-top:-2px; }

    .panel{
      display:grid; grid-gap:10px;
      background:rgba(10,16,34,.55);
      border:1px solid rgba(124,219,255,.18);
      border-radius:18px;
      padding:14px;
      box-shadow:var(--shadow);
    }
    .stats{ display:grid; grid-template-columns:repeat(5,minmax(0,1fr)); grid-gap:10px; }
    .pill{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:10px 12px;
      text-align:center;
      box-shadow:0 10px 28px rgba(0,0,0,.15);
    }
    .pill .label{ font-size:12px; letter-spacing:.6px; text-transform:uppercase; color:var(--muted); margin-bottom:2px; }
    .pill .value{ font-size:18px; font-weight:800; }
    .pill .value.smallValue{ font-size:16px; font-weight:800; }

    .controls{ display:-webkit-flex; display:flex; -webkit-flex-wrap:wrap; flex-wrap:wrap; -webkit-justify-content:center; justify-content:center; -webkit-align-items:center; align-items:center; margin:-5px; }
    .controls > *{ margin:5px; }
    button,.toggle{
      border:0; border-radius:14px; padding:10px 14px;
      font-weight:800; cursor:pointer; -webkit-user-select:none; user-select:none;
      color:var(--text);
      box-shadow:0 12px 26px rgba(0,0,0,.22);
    }
    button{
      background:linear-gradient(180deg, rgba(124,219,255,.18), rgba(124,219,255,.08));
      border:1px solid rgba(124,219,255,.25);
    }
    button:hover{ -webkit-filter:brightness(1.06); filter:brightness(1.06); }
    button:active{ -webkit-transform:translateY(1px); transform:translateY(1px); }
    .toggle{
      display:-webkit-flex; display:flex; -webkit-align-items:center; align-items:center;
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      font-weight:800;
      padding:10px 14px;
    }
    .toggle input{ width:18px; height:18px; margin-right:10px; }
    .message{ text-align:center; font-size:16px; font-size:calc(14px + 0.4vw); color:var(--muted); min-height:26px; }
    .small{ font-size:12px; color:var(--muted); text-align:center; }

    .boardWrap{ display:grid; place-items:center; padding-top:6px; position:relative; }
    .board{
      width:96vw; max-width:940px;
      display:grid; grid-gap:10px;
      padding:14px;
      border-radius:22px;
      background:rgba(8,12,26,.55);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:var(--shadow);
      touch-action:manipulation;
      position:relative;
      z-index:1;
    }

    /* Big card mode gives larger, easier-to-tap cards (by limiting board width a bit and increasing gap/padding) */
    .board.bigMode{
      max-width:760px;
      padding:16px;
      grid-gap:12px;
    }

    .card{
      position:relative;
      border-radius:16px;
      -webkit-transform-style:preserve-3d;
      transform-style:preserve-3d;
      -webkit-transition:-webkit-transform 220ms ease, -webkit-filter 200ms ease;
      transition:transform 220ms ease, filter 200ms ease;
      cursor:pointer;
      -webkit-user-select:none;
      user-select:none;
      background:transparent;
      border:none;
      padding:0;
      -webkit-tap-highlight-color: transparent;
    }
    /* iOS 12 fallback for aspect-ratio */
    .card::before{
      content:"";
      display:block;
      padding-top:100%;
    }
    .card:focus{ outline:3px solid rgba(124,219,255,.55); outline-offset:2px; }
    .card.locked{ cursor:default; }
    .cardInner{ position:absolute; top:0; right:0; bottom:0; left:0; border-radius:16px; -webkit-transform-style:preserve-3d; transform-style:preserve-3d; -webkit-transition:-webkit-transform 220ms ease; transition:transform 220ms ease; }
    .card.isFlipped .cardInner{ -webkit-transform:rotateY(180deg); transform:rotateY(180deg); }
    .face{
      position:absolute; top:0; right:0; bottom:0; left:0;
      display:grid; place-items:center;
      border-radius:16px;
      -webkit-backface-visibility:hidden;
      backface-visibility:hidden;
      box-shadow:0 12px 26px rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
    }
    .front{ background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); }
    .back{
      -webkit-transform:rotateY(180deg);
      transform:rotateY(180deg);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
    }
    .pattern{
      width:70%; height:70%; border-radius:14px;
      background:
        radial-gradient(circle at 20% 30%, rgba(124,219,255,.25) 0 18%, transparent 19%),
        radial-gradient(circle at 70% 60%, rgba(109,255,179,.18) 0 20%, transparent 21%),
        radial-gradient(circle at 40% 80%, rgba(255,109,109,.16) 0 16%, transparent 17%),
        linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.12);
      box-shadow:inset 0 0 0 2px rgba(255,255,255,.05);
    }
    .emoji{
      font-size:32px; font-size:calc(26px + 2.2vw);
      line-height:1;
      -webkit-filter:drop-shadow(0 8px 14px rgba(0,0,0,.25));
      filter:drop-shadow(0 8px 14px rgba(0,0,0,.25));
    }
    /* Legacy/low-power mode (older iOS) */
    body.legacy .emoji{
      -webkit-filter:none;
      filter:none;
    }
    body.legacy .card,
    body.legacy .face,
    body.legacy .board,
    body.legacy .panel,
    body.legacy .pill{
      box-shadow:none;
    }
    body.legacy .card,
    body.legacy .cardInner{
      -webkit-transition:none;
      transition:none;
    }
    body.legacy .wrongFlash,
    body.legacy .winGlow{
      -webkit-animation:none;
      animation:none;
    }
    .matched .back{
      border-color:rgba(109,255,179,.45);
      box-shadow:0 0 0 2px rgba(109,255,179,.18), 0 12px 26px rgba(0,0,0,.25);
    }
    .wrongFlash{ -webkit-animation:wrong 280ms ease; animation:wrong 280ms ease; }
    @-webkit-keyframes wrong{
      0%{ -webkit-filter:drop-shadow(0 0 0 rgba(255,109,109,0)); }
      50%{ -webkit-filter:drop-shadow(0 0 18px rgba(255,109,109,.75)); }
      100%{ -webkit-filter:drop-shadow(0 0 0 rgba(255,109,109,0)); }
    }
    @keyframes wrong{
      0%{ filter:drop-shadow(0 0 0 rgba(255,109,109,0)); }
      50%{ filter:drop-shadow(0 0 18px rgba(255,109,109,.75)); }
      100%{ filter:drop-shadow(0 0 0 rgba(255,109,109,0)); }
    }
    .winGlow{ -webkit-animation:glow 700ms ease-in-out 2; animation:glow 700ms ease-in-out 2; }
    @-webkit-keyframes glow{
      0%{ box-shadow:var(--shadow); }
      50%{ box-shadow:0 0 40px rgba(124,219,255,.25), 0 0 70px rgba(109,255,179,.12), var(--shadow); }
      100%{ box-shadow:var(--shadow); }
    }
    @keyframes glow{
      0%{ box-shadow:var(--shadow); }
      50%{ box-shadow:0 0 40px rgba(124,219,255,.25), 0 0 70px rgba(109,255,179,.12), var(--shadow); }
      100%{ box-shadow:var(--shadow); }
    }

    #confetti{
      position:absolute; top:0; right:0; bottom:0; left:0; z-index:2; pointer-events:none;
    }

    /* ========== POPUP MENU SYSTEM ========== */
    .menuBtn{
      display:none;
      position:fixed;
      z-index:100;
      width:48px; height:48px;
      border-radius:50%;
      background:linear-gradient(180deg, rgba(124,219,255,.25), rgba(124,219,255,.12));
      border:1px solid rgba(124,219,255,.35);
      color:var(--text);
      font-size:22px;
      cursor:pointer;
      box-shadow:0 8px 24px rgba(0,0,0,.35);
      -webkit-transition:-webkit-transform 0.2s ease, background 0.2s ease;
      transition:transform 0.2s ease, background 0.2s ease;
    }
    .menuBtn:hover{ -webkit-transform:scale(1.05); transform:scale(1.05); }
    .menuBtn:active{ -webkit-transform:scale(0.95); transform:scale(0.95); }
    
    #settingsBtn{ top:12px; right:12px; }
    #statsBtn{ top:12px; left:12px; }
    
    .popup{
      display:none;
      position:fixed;
      z-index:200;
      background:rgba(10,16,34,.96);
      border:1px solid rgba(124,219,255,.25);
      border-radius:20px;
      padding:20px;
      box-shadow:0 20px 60px rgba(0,0,0,.5);
      max-width:90vw;
      max-height:80vh;
      overflow-y:auto;
      -webkit-animation:popupIn 0.25s ease;
      animation:popupIn 0.25s ease;
    }
    @-webkit-keyframes popupIn{
      from{ opacity:0; -webkit-transform:scale(0.9) translateY(-10px); }
      to{ opacity:1; -webkit-transform:scale(1) translateY(0); }
    }
    @keyframes popupIn{
      from{ opacity:0; transform:scale(0.9) translateY(-10px); }
      to{ opacity:1; transform:scale(1) translateY(0); }
    }
    .popup.active{ display:block; }
    
    .popupHeader{
      display:-webkit-flex;
      display:flex;
      -webkit-justify-content:space-between;
      justify-content:space-between;
      -webkit-align-items:center;
      align-items:center;
      margin-bottom:16px;
      padding-bottom:12px;
      border-bottom:1px solid rgba(255,255,255,.1);
    }
    .popupTitle{ font-size:18px; font-weight:800; margin:0; }
    .closeBtn{
      width:36px; height:36px;
      border-radius:50%;
      background:rgba(255,255,255,.1);
      border:1px solid rgba(255,255,255,.15);
      color:var(--text);
      font-size:18px;
      cursor:pointer;
      display:-webkit-flex;
      display:flex;
      -webkit-align-items:center;
      align-items:center;
      -webkit-justify-content:center;
      justify-content:center;
    }
    .closeBtn:hover{ background:rgba(255,255,255,.15); }
    
    .popupContent{ display:grid; grid-gap:12px; }
    .popupContent .toggle{ width:100%; -webkit-justify-content:flex-start; justify-content:flex-start; }
    .popupContent button{ width:100%; }
    
    .popupOverlay{
      display:none;
      position:fixed;
      top:0; right:0; bottom:0; left:0;
      background:rgba(0,0,0,.5);
      z-index:150;
    }
    .popupOverlay.active{ display:block; }
    
    /* Stats popup specific */
    #statsPopup .stats{
      grid-template-columns:repeat(2,1fr);
      grid-gap:8px;
    }
    #statsPopup .pill{ padding:8px 10px; }
    
    /* Landscape header bar */
    .landscapeHeader{
      display:none;
      position:fixed;
      top:0; left:0; right:0;
      height:56px;
      background:rgba(10,16,34,.92);
      border-bottom:1px solid rgba(124,219,255,.18);
      z-index:90;
      padding:0 70px;
      -webkit-align-items:center;
      align-items:center;
      -webkit-justify-content:center;
      justify-content:center;
    }
    .landscapeHeader > *{ margin:0 8px; }
    .landscapeHeader h1{
      font-size:20px;
      margin:0 8px;
      white-space:nowrap;
    }
    .landscapeHeader .message{
      font-size:14px;
      min-height:auto;
      -webkit-flex:1;
      flex:1;
      text-align:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    
    /* Compact inline stats for landscape header */
    .inlineStats{
      display:-webkit-flex;
      display:flex;
      -webkit-align-items:center;
      align-items:center;
    }
    .inlineStat{
      display:-webkit-flex;
      display:flex;
      -webkit-align-items:center;
      align-items:center;
      font-size:13px;
      color:var(--muted);
      margin:0 6px;
    }
    .inlineStat .val{
      font-weight:800;
      color:var(--text);
      margin-left:4px;
    }

    @media (max-width: 520px){
      .stats{ grid-template-columns:repeat(2,minmax(0,1fr)); }
      .board{ grid-gap:8px; padding:12px; }
      .board.bigMode{ grid-gap:10px; padding:14px; }
    }
    
    /* ========== iPad Landscape Mode ========== */
    @media (min-width: 700px) and (max-height: 600px) and (orientation: landscape),
           (min-width: 900px) and (max-height: 800px) and (orientation: landscape) {
      body{
        -webkit-align-items:flex-start;
        align-items:flex-start;
      }
      
      .wrap{
        width:100%;
        max-width:100%;
        padding:66px 16px 16px;
        grid-gap:10px;
        min-height:100vh;
      }
      
      /* Hide default header & panel in landscape */
      header{ display:none; }
      .panel{ display:none; }
      
      /* Show landscape header & menu buttons */
      .landscapeHeader{ display:-webkit-flex; display:flex; }
      .menuBtn{ display:-webkit-flex; display:flex; -webkit-align-items:center; align-items:center; -webkit-justify-content:center; justify-content:center; }
      
      /* Board takes full available space */
      .boardWrap{
        -webkit-flex:1;
        flex:1;
        display:-webkit-flex;
        display:flex;
        -webkit-align-items:center;
        align-items:center;
        -webkit-justify-content:center;
        justify-content:center;
        padding:0;
        width:100%;
        height:calc(100vh - 72px);
      }
      
      .board{
        width:calc(100vh - 90px);
        height:calc(100vh - 90px);
        max-height:90vw;
        max-width:90vw;
        padding:12px;
        grid-gap:8px;
      }
      .board.bigMode{
        width:calc(100vh - 90px);
        height:calc(100vh - 90px);
        max-height:85vw;
        max-width:85vw;
        padding:14px;
        grid-gap:10px;
      }
      
      .emoji{ font-size:28px; font-size:calc(20px + 2vh); }
      
      /* Popup positioning for landscape */
      #settingsPopup{
        top:70px;
        right:12px;
        width:280px;
      }
      #statsPopup{
        top:70px;
        left:12px;
        width:260px;
      }
    }
    
    /* Extra wide landscape (iPad Pro, etc) */
    @media (min-width: 1000px) and (max-height: 850px) and (orientation: landscape) {
      .board{
        width:calc(100vh - 80px);
        height:calc(100vh - 80px);
        max-height:70vw;
        max-width:70vw;
        grid-gap:10px;
        padding:14px;
      }
      .board.bigMode{
        width:calc(100vh - 80px);
        height:calc(100vh - 80px);
        max-height:65vw;
        max-width:65vw;
      }
      .emoji{ font-size:32px; font-size:calc(24px + 2.5vh); }
    }
  </style>
</head>
<body>
  <!-- Landscape Header Bar -->
  <div class="landscapeHeader">
    <h1>ğŸ“ Fruit Match</h1>
    <div class="inlineStats">
      <div class="inlineStat"><span class="val" id="gridValueL">4Ã—4</span></div>
      <div class="inlineStat">â±<span class="val" id="timeValueL">0:00</span></div>
      <div class="inlineStat">ğŸ‘†<span class="val" id="movesValueL">0</span></div>
      <div class="inlineStat">âœ“<span class="val" id="matchesValueL">0/0</span></div>
      <div class="inlineStat">ğŸ†<span class="val" id="winsValueL">0</span></div>
    </div>
    <div class="message" id="messageL"></div>
  </div>
  
  <!-- Menu Buttons (visible in landscape) -->
  <button class="menuBtn" id="statsBtn" title="Stats">ğŸ“Š</button>
  <button class="menuBtn" id="settingsBtn" title="Settings">âš™ï¸</button>
  
  <!-- Popup Overlay -->
  <div class="popupOverlay" id="popupOverlay"></div>
  
  <!-- Stats Popup -->
  <div class="popup" id="statsPopup">
    <div class="popupHeader">
      <h2 class="popupTitle">ğŸ“Š Stats</h2>
      <button class="closeBtn" data-close="statsPopup">âœ•</button>
    </div>
    <div class="popupContent">
      <div class="stats">
        <div class="pill"><div class="label">Grid</div><div class="value" id="gridValueP">4Ã—4</div></div>
        <div class="pill"><div class="label">Time</div><div class="value" id="timeValueP">0:00</div></div>
        <div class="pill"><div class="label">Moves</div><div class="value" id="movesValueP">0</div></div>
        <div class="pill"><div class="label">Matches</div><div class="value smallValue" id="matchesValueP">0/0</div></div>
        <div class="pill"><div class="label">Wins</div><div class="value" id="winsValueP">0</div></div>
      </div>
    <div class="small" id="levelInfoP" style="margin-top:8px;">
        Level up every <b>3 wins</b>: 4Ã—4 â†’ 6Ã—6 â†’ 8Ã—8 â†’ 10Ã—10
      </div>
    </div>
  </div>
  
  <!-- Settings Popup -->
  <div class="popup" id="settingsPopup">
    <div class="popupHeader">
      <h2 class="popupTitle">âš™ï¸ Settings</h2>
      <button class="closeBtn" data-close="settingsPopup">âœ•</button>
    </div>
    <div class="popupContent">
      <button id="newGameBtnP">ğŸ® New Game</button>
      <button id="peekBtnP" title="Peek at all cards">ğŸ‘€ Peek</button>
      <button id="resetBtnP">ğŸ”„ Reset Progress</button>
      <label class="toggle"><input id="soundToggleP" type="checkbox" checked />ğŸ”Š Sound</label>
      <label class="toggle"><input id="easyToggleP" type="checkbox" />ğŸ˜Š Easy mode</label>
      <label class="toggle"><input id="voiceToggleP" type="checkbox" />ğŸ—£ï¸ Kid voice</label>
      <label class="toggle"><input id="bigToggleP" type="checkbox" />ğŸ‘† Big card mode</label>
    </div>
  </div>

  <div class="wrap">
    <header>
      <h1>ğŸ“ Fruit Match Memory</h1>
      <div class="sub">Flip two cards. If they match, they stay open. Match all to win!</div>
    </header>

    <div class="panel">
      <div class="stats">
        <div class="pill"><div class="label">Grid</div><div class="value" id="gridValue">4Ã—4</div></div>
        <div class="pill"><div class="label">Time</div><div class="value" id="timeValue">0:00</div></div>
        <div class="pill"><div class="label">Moves</div><div class="value" id="movesValue">0</div></div>
        <div class="pill"><div class="label">Matches</div><div class="value smallValue" id="matchesValue">0/0</div></div>
        <div class="pill"><div class="label">Wins</div><div class="value" id="winsValue">0</div></div>
      </div>

      <div class="controls">
        <button id="newGameBtn">New Game</button>
        <button id="peekBtn" title="Peek at all cards for a moment">Peek ğŸ‘€</button>
        <button id="resetBtn">Reset Progress</button>

        <label class="toggle" title="Sound beeps on/off"><input id="soundToggle" type="checkbox" checked />Sound</label>
        <label class="toggle" title="Easy mode: longer peek + optional peek after mistakes"><input id="easyToggle" type="checkbox" />Easy mode</label>
        <label class="toggle" title="Kid voice: says short phrases"><input id="voiceToggle" type="checkbox" />Kid voice</label>
        <label class="toggle" title="Big cards: easier taps (limits grid on small screens)"><input id="bigToggle" type="checkbox" />Big card mode</label>
      </div>

      <div class="message" id="message"></div>
      <div class="small" id="levelInfo">
        Even grids only: <b>4Ã—4 â†’ 6Ã—6 â†’ 8Ã—8 â†’ 10Ã—10</b> (level up every <b>3 wins</b>). â­ rating + confetti on win!
      </div>
    </div>

    <div class="boardWrap" id="boardWrap">
      <canvas id="confetti"></canvas>
      <div class="board" id="board" aria-label="Memory board"></div>
    </div>
  </div>

<script>
(() => {
  // Fruit emoji icons
  const FRUITS = [
    "ğŸ","ğŸ","ğŸŠ","ğŸ‹","ğŸŒ","ğŸ‰","ğŸ‡","ğŸ“","ğŸ«","ğŸ’",
    "ğŸ¥","ğŸ","ğŸ¥­","ğŸ‘","ğŸˆ","ğŸ","ğŸ…","ğŸ¥¥","ğŸ’","ğŸŠ",
    "ğŸ“","ğŸ‡","ğŸ‰","ğŸ","ğŸ¥","ğŸ","ğŸ¥­","ğŸ«","ğŸ‹","ğŸŒ",
    "ğŸ‘","ğŸˆ","ğŸ","ğŸ","ğŸ¥¥","ğŸ…","ğŸ’","ğŸŠ","ğŸ‡","ğŸ“",
    "ğŸ«","ğŸ¥","ğŸ","ğŸ¥­","ğŸ","ğŸ","ğŸ‰","ğŸŒ","ğŸ‹","ğŸŠ"
  ];

  function getIOSMajorVersion(){
    const ua = navigator.userAgent || "";
    const match = ua.match(/OS (\d+)_/);
    if (!match) return null;
    return parseInt(match[1], 10);
  }
  function isLegacyIOS(){
    const ua = navigator.userAgent || "";
    if (!/iP(hone|ad|od)/.test(ua)) return false;
    const major = getIOSMajorVersion();
    return major !== null && major <= 12;
  }
  const legacyMode = isLegacyIOS();
  if (legacyMode) document.body.classList.add("legacy");
  const LEGACY_MAX_GRID = 8;

  // State
  let wins = 0;
  let gridSize = 4;
  let moves = 0;
  let matches = 0;
  let totalPairs = 0;

  let firstPick = null;
  let secondPick = null;
  let busy = false;
  let wonThisRound = false;

  // Timer
  let timerId = null;
  let startMs = 0;
  let elapsedMs = 0;
  let timerRunning = false;

  // DOM - Main panel
  const board = document.getElementById("board");
  const boardWrap = document.getElementById("boardWrap");

  const gridValue = document.getElementById("gridValue");
  const timeValue = document.getElementById("timeValue");
  const movesValue = document.getElementById("movesValue");
  const matchesValue = document.getElementById("matchesValue");
  const winsValue = document.getElementById("winsValue");
  const message = document.getElementById("message");

  const newGameBtn = document.getElementById("newGameBtn");
  const resetBtn = document.getElementById("resetBtn");
  const peekBtn = document.getElementById("peekBtn");

  const soundToggle = document.getElementById("soundToggle");
  const easyToggle  = document.getElementById("easyToggle");
  const voiceToggle = document.getElementById("voiceToggle");
  const bigToggle   = document.getElementById("bigToggle");
  
  // DOM - Landscape header
  const gridValueL = document.getElementById("gridValueL");
  const timeValueL = document.getElementById("timeValueL");
  const movesValueL = document.getElementById("movesValueL");
  const matchesValueL = document.getElementById("matchesValueL");
  const winsValueL = document.getElementById("winsValueL");
  const messageL = document.getElementById("messageL");
  
  // DOM - Popups
  const statsBtn = document.getElementById("statsBtn");
  const settingsBtn = document.getElementById("settingsBtn");
  const popupOverlay = document.getElementById("popupOverlay");
  const statsPopup = document.getElementById("statsPopup");
  const settingsPopup = document.getElementById("settingsPopup");
  
  // DOM - Popup stats
  const gridValueP = document.getElementById("gridValueP");
  const timeValueP = document.getElementById("timeValueP");
  const movesValueP = document.getElementById("movesValueP");
  const matchesValueP = document.getElementById("matchesValueP");
  const winsValueP = document.getElementById("winsValueP");
  
  // DOM - Popup controls
  const newGameBtnP = document.getElementById("newGameBtnP");
  const resetBtnP = document.getElementById("resetBtnP");
  const peekBtnP = document.getElementById("peekBtnP");
  const soundToggleP = document.getElementById("soundToggleP");
  const easyToggleP = document.getElementById("easyToggleP");
  const voiceToggleP = document.getElementById("voiceToggleP");
  const bigToggleP = document.getElementById("bigToggleP");
  const levelInfo = document.getElementById("levelInfo");
  const levelInfoP = document.getElementById("levelInfoP");

  // Confetti
  const confettiCanvas = document.getElementById("confetti");
  const ctx = confettiCanvas.getContext && confettiCanvas.getContext("2d");
  let confetti = [];
  let confettiRAF = null;

  // --- Sound beeps (WebAudio)
  let audioCtx = null;
  function beep(freq=440, dur=0.08, type="sine", gain=0.04) {
    if (!soundToggle.checked) return;
    try {
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch(e) {}
  }
  const soundFlip  = () => beep(520, 0.05, "sine", 0.03);
  const soundMatch = () => { beep(740,0.07,"triangle",0.05); beep(980,0.08,"triangle",0.05); };
  const soundWrong = () => beep(200, 0.12, "sawtooth", 0.03);
  const soundWin   = () => { beep(660,0.09,"triangle",0.06); setTimeout(()=>beep(880,0.1,"triangle",0.06),90); setTimeout(()=>beep(1100,0.12,"triangle",0.06),180); };

  // --- Kid voice (speechSynthesis)
  function speak(text) {
    if (!voiceToggle.checked) return;
    if (!("speechSynthesis" in window)) return;
    try {
      // Stop overlapping chatter
      window.speechSynthesis.cancel();

      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0;   // kid-friendly pace
      u.pitch = 1.2;  // a bit brighter
      u.volume = 1.0;

      // Try to pick an English voice if available
      var voices = [];
      try { voices = window.speechSynthesis.getVoices() || []; } catch(e) {}
      var en = voices.find(function(v){ return /en/i.test(v.lang); }) || voices[0];
      if (en) u.voice = en;

      window.speechSynthesis.speak(u);
    } catch(e) {}
  }

  // Some browsers load voices async
  if ("speechSynthesis" in window) {
    window.speechSynthesis.onvoiceschanged = () => {};
  }

  // Helpers
  const now = () => (window.performance && performance.now ? performance.now() : Date.now());
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  function setGridGap(el, px){
    const value = (typeof px === "number") ? (px + "px") : px;
    el.style.gap = value;
    el.style.gridGap = value;
    el.style.rowGap = value;
    el.style.columnGap = value;
  }
  function addTapListener(el, handler){
    let lastTouch = 0;
    el.addEventListener("touchend", (e) => {
      lastTouch = Date.now();
      e.preventDefault();
      handler(e);
    });
    el.addEventListener("click", (e) => {
      if (Date.now() - lastTouch < 350) return;
      handler(e);
    });
  }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  function chooseIcons(pairCount){
    const pool = FRUITS.slice();
    shuffle(pool);
    if(pairCount <= pool.length) return pool.slice(0, pairCount);
    const out=[];
    for(let i=0;i<pairCount;i++) out.push(pool[i % pool.length]);
    return out;
  }
  function formatTime(ms){
    const totalSec = Math.floor(ms/1000);
    const m = Math.floor(totalSec/60);
    const s = totalSec%60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }
  function setMessage(text, tone=""){
    const color =
      tone==="good" ? "rgba(109,255,179,.95)" :
      tone==="bad"  ? "rgba(255,109,109,.95)" :
                      "rgba(234,242,255,0.7)";
    message.textContent = text;
    message.style.color = color;
    // Also update landscape message
    if(messageL){
      messageL.textContent = text;
      messageL.style.color = color;
    }
  }
  function updateStats(){
    const gridText = `${gridSize}Ã—${gridSize}`;
    const timeText = formatTime(elapsedMs);
    const matchText = `${matches}/${totalPairs}`;
    
    // Main panel
    gridValue.textContent = gridText;
    movesValue.textContent = moves;
    matchesValue.textContent = matchText;
    winsValue.textContent = wins;
    timeValue.textContent = timeText;
    
    // Landscape header
    if(gridValueL) gridValueL.textContent = gridText;
    if(timeValueL) timeValueL.textContent = timeText;
    if(movesValueL) movesValueL.textContent = moves;
    if(matchesValueL) matchesValueL.textContent = matchText;
    if(winsValueL) winsValueL.textContent = wins;
    
    // Popup stats
    if(gridValueP) gridValueP.textContent = gridText;
    if(timeValueP) timeValueP.textContent = timeText;
    if(movesValueP) movesValueP.textContent = moves;
    if(matchesValueP) matchesValueP.textContent = matchText;
    if(winsValueP) winsValueP.textContent = wins;
  }

  function applyLegacyText(){
    if (!legacyMode) return;
    const capText = "4Ã—4 â†’ 6Ã—6 â†’ 8Ã—8";
    if (levelInfo) {
      levelInfo.innerHTML = "Even grids only: <b>" + capText + "</b> (level up every <b>3 wins</b>). â­ rating + confetti on win!";
    }
    if (levelInfoP) {
      levelInfoP.innerHTML = "Level up every <b>3 wins</b>: " + capText;
    }
  }
  applyLegacyText();

  function gridFromWins(w){
    // Every 3 wins: 4 -> 6 -> 8 -> 10
    const steps = Math.floor(w / 3);
    return clamp(4 + steps * 2, 4, 10);
  }

  function effectiveMaxGrid(){
    // Big card mode keeps it playable on touch screens.
    // If screen is small, limit to 8x8; otherwise allow 10x10.
    if (legacyMode) return LEGACY_MAX_GRID;
    if (!bigToggle.checked) return 10;
    const smallScreen = Math.min(window.innerWidth, window.innerHeight) < 700;
    return smallScreen ? 8 : 10;
  }

  function computeGridForThisRound(){
    const desired = gridFromWins(wins);
    return Math.min(desired, effectiveMaxGrid());
  }

  function setBoardDensity(n){
    // slightly larger gaps in big mode for tap comfort
    if (bigToggle.checked) {
      board.classList.add("bigMode");
    } else {
      board.classList.remove("bigMode");
    }

    const baseGap =
      bigToggle.checked ? (n>=10 ? 7 : n>=8 ? 10 : n>=6 ? 12 : 12)
                        : (n>=10 ? 5 : n>=8 ? 7 : n>=6 ? 9 : 10);
    setGridGap(board, baseGap);
  }

  // Timer controls
  function stopTimer(){
    timerRunning = false;
    if(timerId) clearInterval(timerId);
    timerId = null;
  }
  function startTimer(){
    if(timerRunning) return;
    timerRunning = true;
    startMs = now() - elapsedMs;
    timerId = setInterval(() => {
      elapsedMs = now() - startMs;
      const timeText = formatTime(elapsedMs);
      timeValue.textContent = timeText;
      if(timeValueL) timeValueL.textContent = timeText;
      if(timeValueP) timeValueP.textContent = timeText;
    }, 200);
  }
  function resetTimer(){
    stopTimer();
    elapsedMs = 0;
    timeValue.textContent = "0:00";
  }

  // Cards
  function createCard(icon){
    const card = document.createElement("button");
    card.type = "button";
    card.className = "card";
    card.setAttribute("aria-label", "Memory card");
    card.dataset.icon = icon;
    card.dataset.matched = "false";
    card.dataset.locked = "false";

    card.innerHTML = `
      <div class="cardInner">
        <div class="face front"><div class="pattern"></div></div>
        <div class="face back"><div class="emoji">${icon}</div></div>
      </div>
    `;
    // Click is enough for touch too; we also stop double-tap zoom issues via viewport/meta + tap highlight.
    addTapListener(card, () => onCardClick(card));
    card.addEventListener("keydown", (e)=>{
      if(e.key==="Enter" || e.key===" "){ e.preventDefault(); onCardClick(card); }
    });
    return card;
  }

  function flip(card, on){
    if(on) card.classList.add("isFlipped");
    else card.classList.remove("isFlipped");
  }

  // Easy mode behavior
  function easyStartPeekMs(){
    return easyToggle.checked ? 1400 : 650;
  }
  function easyAfterWrongPeekMs(){
    // When easy mode is on, after a wrong match, briefly reveal all cards again.
    return easyToggle.checked ? 650 : 0;
  }

  // Game build
  function newGame(){
    wonThisRound = false;
    gridSize = computeGridForThisRound();

    const totalCards = gridSize * gridSize;
    totalPairs = totalCards / 2;

    moves = 0;
    matches = 0;
    firstPick = null;
    secondPick = null;
    busy = false;

    resetTimer();

    board.innerHTML = "";
    board.classList.remove("winGlow");

    board.style.gridTemplateColumns = legacyMode
      ? `repeat(${gridSize}, 1fr)`
      : `repeat(${gridSize}, minmax(0, 1fr))`;
    setBoardDensity(gridSize);

    const icons = chooseIcons(totalPairs);
    const deck = [];
    icons.forEach(icon => deck.push(icon, icon));
    shuffle(deck);

    for(const icon of deck){
      board.appendChild(createCard(icon));
    }

    setMessage(`New game! Match all the fruits!`);
    speak("New game! Let's match the fruits!");
    updateStats();

    peek(easyStartPeekMs());
  }

  function onCardClick(card){
    if (busy || wonThisRound) return;
    if (card.dataset.locked === "true") return;
    if (card.dataset.matched === "true") return;
    if (card === firstPick) return;

    startTimer();
    flip(card, true);
    soundFlip();

    if(!firstPick){
      firstPick = card;
      return;
    }

    secondPick = card;
    moves += 1;
    updateStats();

    const a = firstPick.dataset.icon;
    const b = secondPick.dataset.icon;

    if(a === b){
      firstPick.dataset.matched = "true";
      secondPick.dataset.matched = "true";
      firstPick.classList.add("matched","locked");
      secondPick.classList.add("matched","locked");

      matches += 1;
      updateStats();
      soundMatch();
      const msg = randomHappy();
      setMessage(msg, "good");
      speak("Yay! A match!");

      firstPick = null;
      secondPick = null;

      if(matches === totalPairs){
        handleWin();
      }
    } else {
      busy = true;
      soundWrong();
      firstPick.classList.add("wrongFlash");
      secondPick.classList.add("wrongFlash");
      const msg = randomTryAgain();
      setMessage(msg, "bad");
      speak("Oops! Try again!");

      setTimeout(()=>{
        flip(firstPick,false);
        flip(secondPick,false);
        firstPick.classList.remove("wrongFlash");
        secondPick.classList.remove("wrongFlash");
        firstPick=null; secondPick=null;

        // Easy mode: quick â€œhelp peekâ€ after mistakes
        const helpMs = easyAfterWrongPeekMs();
        if (helpMs > 0) {
          peek(helpMs);
        }
        busy=false;
      }, 650);
    }
  }

  // Stars
  function computeStars(grid, moves, elapsedMs){
    const pairs = (grid*grid)/2;
    const seconds = Math.max(1, Math.floor(elapsedMs/1000));

    // Easy mode makes rating a bit more forgiving (kids are learning)
    const easyBonus = easyToggle.checked ? 0.15 : 0;

    const movePerfect = pairs + Math.round(pairs*(0.25 + easyBonus));
    const moveOkay    = pairs + Math.round(pairs*(0.75 + easyBonus));

    const timePerfect = Math.round(pairs*(3 + easyBonus*3));
    const timeOkay    = Math.round(pairs*(6 + easyBonus*5));

    let stars = 1;
    const greatMoves = moves <= movePerfect;
    const goodMoves  = moves <= moveOkay;
    const greatTime  = seconds <= timePerfect;
    const goodTime   = seconds <= timeOkay;

    if (goodMoves && goodTime) stars = 2;
    if (greatMoves && greatTime) stars = 3;
    return stars;
  }
  const starsText = n => "â­".repeat(n) + "â˜†".repeat(3-n);

  function handleWin(){
    wonThisRound = true;
    stopTimer();
    soundWin();
    board.classList.add("winGlow");

    const stars = computeStars(gridSize, moves, elapsedMs);
    const starLine = `${starsText(stars)} (${formatTime(elapsedMs)}, ${moves} moves)`;

    wins += 1;
    updateStats();

    launchConfetti(1600);

    // Level info (even grids only)
    const desiredNext = gridFromWins(wins);
    const nextGrid = Math.min(desiredNext, effectiveMaxGrid());
    const leveledUp = nextGrid !== gridSize;

    if (leveledUp){
      setMessage(`ğŸ‰ You won! ${starLine}  Level up! Next: ${nextGrid}Ã—${nextGrid}`, "good");
      speak("You won! Level up!");
    } else {
      const remaining = 3 - (wins % 3);
      setMessage(`ğŸ‰ You won! ${starLine}  ${remaining} more win${remaining===1?"":"s"} to level up!`, "good");
      speak("You won! Great job!");
    }

    // If big mode capped the grid, hint gently
    if (bigToggle.checked && desiredNext > nextGrid) {
      setTimeout(() => {
        setMessage(`ğŸˆ Big card mode is keeping the grid at ${nextGrid}Ã—${nextGrid} for easier tapping.`, "");
      }, 1400);
    } else if (legacyMode && desiredNext > nextGrid) {
      setTimeout(() => {
        setMessage(`ğŸ“± Older iOS devices keep the grid at ${nextGrid}Ã—${nextGrid} for smoother play.`, "");
      }, 1400);
    }
  }

  // Peek helper
  function peek(durationMs=900){
    if(busy) return;
    busy = true;
    const nodeList = board.querySelectorAll(".card");
    const cards = [];
    for(let i=0;i<nodeList.length;i++) cards.push(nodeList[i]);
    cards.forEach(c => flip(c,true));
    setTimeout(()=>{
      cards.forEach(c => { if(c.dataset.matched !== "true") flip(c,false); });
      busy = false;
    }, durationMs);
  }

  function resetProgress(){
    wins = 0;
    setMessage("Progress reset. Back to 4Ã—4!", "");
    speak("Reset! Back to the easy level.");
    newGame();
  }

  function randomHappy(){
    const msgs=["Nice match! ğŸŒŸ","Yay! You found a pair! ğŸ“","Great job! ğŸˆ","Awesome! ğŸš€","Perfect match! ğŸ‰"];
    return msgs[Math.floor(Math.random()*msgs.length)];
  }
  function randomTryAgain(){
    const msgs=["Oops! Try again ğŸ™‚","Not the sameâ€¦ you can do it! ğŸ’ª","Close! Flip two more! ğŸ§ ","Keep trying! â­","Almost! ğŸŒˆ"];
    return msgs[Math.floor(Math.random()*msgs.length)];
  }

  // Confetti
  function resizeConfettiCanvas(){
    if (!ctx) return;
    const r = boardWrap.getBoundingClientRect();
    if (!r.width || !r.height) return;
    const dpr = window.devicePixelRatio || 1;
    confettiCanvas.width = Math.floor(r.width * dpr);
    confettiCanvas.height = Math.floor(r.height * dpr);
    confettiCanvas.style.width = r.width + "px";
    confettiCanvas.style.height = r.height + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  function cancelConfetti(){
    if (!ctx) return;
    if(confettiRAF) cancelAnimationFrame(confettiRAF);
    confettiRAF = null;
    confetti = [];
    ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
  }
  function launchConfetti(durationMs=1200){
    if (!ctx) return;
    cancelConfetti();
    resizeConfettiCanvas();

    const r = boardWrap.getBoundingClientRect();
    const w = r.width, h = r.height;
    if (!w || !h) return;

    const count = legacyMode
      ? Math.min(140, Math.max(60, gridSize * gridSize * 0.7))
      : Math.min(240, Math.max(90, gridSize * gridSize * 1.2));
    confetti = [];
    for(let i=0;i<count;i++){
      confetti.push({
        x: w * (0.2 + Math.random()*0.6),
        y: -10 - Math.random()*h*0.2,
        vx: (Math.random()*2 - 1) * (1.2 + Math.random()*1.5),
        vy: (2.2 + Math.random()*3.2),
        rot: Math.random()*Math.PI*2,
        vr: (Math.random()*0.2 - 0.1),
        size: 6 + Math.random()*8,
        life: 0,
        maxLife: 60 + Math.random()*55,
        hue: Math.floor(Math.random()*360),
        shape: Math.random() < 0.25 ? "circle" : "rect"
      });
    }

    const duration = legacyMode ? Math.min(900, durationMs) : durationMs;
    const endAt = now() + duration;
    function tick(){
      const t = now();
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

      for(const p of confetti){
        p.life++;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.03;
        p.vx *= 0.995;
        p.rot += p.vr;

        const alpha = 1 - (p.life / p.maxLife);
        if(alpha <= 0) continue;

        ctx.save();
        ctx.globalAlpha = Math.max(0, alpha);
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = "hsl(" + p.hue + ", 90%, 60%)";

        if(p.shape === "circle"){
          ctx.beginPath();
          ctx.arc(0,0,p.size*0.45,0,Math.PI*2);
          ctx.fill();
        } else {
          ctx.fillRect(-p.size/2, -p.size/3, p.size, p.size*0.66);
        }
        ctx.restore();
      }

      confetti = confetti.filter(p => p.life < p.maxLife && p.y < h + 80);

      if(t < endAt && confetti.length){
        confettiRAF = requestAnimationFrame(tick);
      } else {
        cancelConfetti();
      }
    }
    confettiRAF = requestAnimationFrame(tick);
  }

  // Buttons + toggles (main panel)
  addTapListener(newGameBtn, () => newGame());
  addTapListener(resetBtn, () => resetProgress());
  addTapListener(peekBtn, () => peek(easyToggle.checked ? 1400 : 900));

  // Sync function for toggles
  function syncToggle(main, popup, onChange){
    main.addEventListener("change", () => {
      popup.checked = main.checked;
      onChange(main.checked);
    });
    popup.addEventListener("change", () => {
      main.checked = popup.checked;
      onChange(popup.checked);
    });
  }
  
  // Sound toggle sync (no game restart needed)
  syncToggle(soundToggle, soundToggleP, () => {});
  
  // Easy toggle sync
  syncToggle(easyToggle, easyToggleP, (checked) => {
    setMessage(checked ? "Easy mode on! ğŸ‘" : "Easy mode off!", "");
    speak(checked ? "Easy mode on!" : "Easy mode off!");
    newGame();
  });
  
  // Big card toggle sync
  syncToggle(bigToggle, bigToggleP, (checked) => {
    setMessage(checked ? "Big card mode on! ğŸ‘†" : "Big card mode off!", "");
    speak(checked ? "Big card mode on!" : "Big card mode off!");
    newGame();
  });
  
  // Voice toggle sync
  syncToggle(voiceToggle, voiceToggleP, (checked) => {
    setMessage(checked ? "Kid voice on! ğŸ—£ï¸" : "Kid voice off!", "");
    if(checked) speak("Hello! Let's play!");
    else if("speechSynthesis" in window) window.speechSynthesis.cancel();
  });
  
  // Popup buttons
  addTapListener(newGameBtnP, () => { closeAllPopups(); newGame(); });
  addTapListener(resetBtnP, () => { closeAllPopups(); resetProgress(); });
  addTapListener(peekBtnP, () => { closeAllPopups(); peek(easyToggle.checked ? 1400 : 900); });
  
  // Popup menu handling
  function openPopup(popup){
    closeAllPopups();
    popup.classList.add("active");
    popupOverlay.classList.add("active");
  }
  function closeAllPopups(){
    statsPopup.classList.remove("active");
    settingsPopup.classList.remove("active");
    popupOverlay.classList.remove("active");
  }
  
  addTapListener(statsBtn, () => openPopup(statsPopup));
  addTapListener(settingsBtn, () => openPopup(settingsPopup));
  addTapListener(popupOverlay, closeAllPopups);
  
  // Close buttons inside popups
  document.querySelectorAll(".closeBtn[data-close]").forEach(function(btn) {
    addTapListener(btn, function() {
      var popupId = btn.getAttribute("data-close");
      var popup = document.getElementById(popupId);
      if (popup) popup.classList.remove("active");
      popupOverlay.classList.remove("active");
    });
  });
  
  // Close popup on Escape key
  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape") closeAllPopups();
  });

  // Keep confetti correct on resize
  window.addEventListener("resize", () => { if(confettiRAF) resizeConfettiCanvas(); });

  // Start
  newGame();
})();
</script>
</body>
</html>